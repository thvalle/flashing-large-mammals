---
title: "GLMM per art"
author: "Torgeir Holmgard Valle"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    keep_md: true
---

```{r setup}
library(tidyverse)
library(lme4)
library(cowplot)
library(performance) # diagnostic-plots to check assumptions
library(report)      # Result-summaries in text-format
library(ggeffects)   # Estimated Marginal Means and Marginal Effects from Regression Models
                          # more at: https://strengejacke.github.io/ggeffects/
library(parameters)  # extract model-parameters etc. from (most) models
library(sjPlot)      # parameters + sjPlot probably does a similar and better job than ggeffects
library(see)         # plot-related package from the easystats-verse

# Data drom Data_exploration2_nesting.R
time.dep <- readRDS("timedep.rds")

ctrl <- c("Control_1", "Control_2", "Control_3","Control_4")
obs      <- readRDS("Observations_prepared1.rds") %>% 
  mutate(flash = ifelse(period %in% ctrl, "Control",flash))
obs <- obs %>% 
  mutate(species = validated_species,
         Hour = as.numeric(format(obs$datetime, "%H")), # for density-plots
         flash = factor(obs$flash, labels = c("IR", "wLED","Control"))) # --||--
# Set global plot theme
theme_set(ggpubr::theme_classic2())
sp_focus <- c("raadyr", "rev", "grevling", "hare", "ekorn", "elg", "hjort", "maar", "gaupe")
```

## Purpose

Modelling detection rates of the nine most common wild animals in my dataset, producing the plots I am going to use in my thesis

# About the model

### Why GLMM?

Response from a [stackexchange question](https://stats.stackexchange.com/questions/226946/r-lmer-vs-glmer)
about the differences of `lmer` and `glmer`-functions:

>lmer is used to fit linear mixed-effect models, so it assumes that the residual error has a Gaussian distribution. If your dependent variable A is a binary outcome (e.g. a yes/no response), then the error distribution is binomial and not Gaussian. In this case you have to use glmer, which allow to fit a generalized linear mixed-effects model: these models include a link function that allows to predict response variables with non-Gaussian distributions. One example of link function that could work in your case is the logistic function, which takes an input with any value from negative to positive infinity and return an output that always takes values between zero and one, which is interpretable as the probability of the binary outcome (e.g. the probability of the subject responding 'yes').




### Formula
The model formula I will use is $n \sim \ time.deploy\ * flash $ for each species, and my $\alpha = 0.05$.

```{r timedep2}
time.dep2 <- time.dep %>% 
  rename(species = validated_species) %>%  #shortening name
# including Control as part of the flash-column, since it differs from flash=0
  mutate(flash = factor(
        ifelse(period %in% ctrl, "Control", flash)),
        week = lubridate::isoweek(date),
        period = factor(period))
time.dep2 <- time.dep2 %>% 
   mutate(flash = fct_relevel(flash, "Control","0","1")) # relevel to make Control the model intercept
levels(time.dep2$flash) <- c("Control", "IR", "wLED")
levels(time.dep2$period) <- c("IR_1", "IR_2", "wLED_1", "wLED_2", "Control_1", "Control_2", "Control_3", "Control_4")
```

```{r IR-control, eval=FALSE}
# stations <- readRDS("stations.rds") %>% mutate(loc = as.factor(loc))
# time.dep2 <- time.dep2 %>% left_join(stations) 
# # IR-periods in group C are identical to Control-groups
# time.dep2$flash[time.dep2$period == "IR_1" & time.dep2$abc == "C"] <- "Control"
```


Not all periods have identical length. Hence, I need to set a maximum length for my period durations. As proposed by my supervisor Neri Thorsen, I will calculate the median for the different types of periods, and use the smallest median to shorten all periods overextending that value.


```{r period-median, message=FALSE}
# find median period length
time.period <- time.dep2 %>% group_by(loc, period, flash) %>% 
  summarise(period_length = max(time.deploy))

# checking shortest periods
time.period %>% arrange(period_length) # 1 period (wLED) is 0 days

# then merge lengths and filter out period of 0 days
time.dep3 <- time.dep2 %>% left_join(time.period) %>% 
  filter(period_length > 0)

# find median length 
time.period %>% filter(flash == "wLED") %>%  
  summary() # median period length 85 days, mean: 84
time.period %>% filter(flash == "IR") %>%  
  summary() # median period length 84 days, mean: 89
time.period %>% filter(flash == "Control") %>%  
  summary() # median period length 89 days, mean: 93

# extract lengths of each unique period
h <- time.dep3 %>% group_by(loc, period, period_length, flash)%>% nest() %>% 
  select(!data) 
#extracting median and multiplying by 10, to use in the correctly scaled plot
hh <-       h$period_length[h$flash == "wLED"]      %>%  median()       #  white LED
hh <- c(hh, h$period_length[h$flash == "IR" ]      %>%  median())      # +  IR
hh <- c(hh, h$period_length[h$flash == "Control" ] %>%  median()) * 10 # +  Control
# smallest median 
h <- min(hh)
h # 84 shortest median (IR)
```


The IR median is 84 days, white LED is 84,5 and control is 89. 84 is trimming value.



```{r period-length, message=FALSE, eval=FALSE}
# plot periods with median as intercept
p_td <- time.dep3 %>% filter(!period %in% ctrl) %>% #removing ctrl-periods
  ggplot(aes(loc, 10*time.deploy, colour = period, ))  +
  geom_line(aes(linetype = flash),position = position_dodge(width = 1), lineend = "square") +
  coord_flip() + 
  labs(title = "Period lengths per camera",
       x = "Location", y = "Time since deployment",
       caption = "Vertical lines reprecent median period lengths for IR and white LED.\n Data superceding that were trimmed away for the GLMM-modelling.") 
  #ggpubr::theme_classic2() #+ theme(legend.position = "right") find way to set legend inside
p_td + geom_hline(aes(yintercept = h), linetype = "dashed",  alpha =.5) +
  geom_hline(aes(yintercept = max(hh)), linetype = "dashed",  alpha =.5) +
  #annotate(geom = "text",x=4, y=h+8.6, label = "- median", size = 3, alpha =.7) +
  scale_y_continuous(breaks = sort(c(0, 50, h, 100, 150))) +
  scale_color_brewer(palette = "Spectral")
# failed attempts that could inspire a better plot later
# p_td + geom_hline(aes(yintercept = h))+ # using median days as intercept 
#        scale_y_continuous(breaks = sort(c(ggplot_build(p_td)$layout$panel_ranges[[1]]$y.major_source, h)))
# geom_text(aes(25, h, label = "median", vjust = -1), nudge_y = 10, show.legend = F)
```


```{r period-length-wControl, message=FALSE, warning=FALSE}
# remake plot with Control-group data, faceted
p_td2 <- time.dep3 %>% 
  ggplot(aes(loc, 10*time.deploy, col = period))  +
  geom_line(aes(linetype = period),
    position = position_dodge(width = 1), lineend = "square") +
  coord_flip() +  
  geom_hline(aes(yintercept = h), linetype = "dashed",  alpha =.5) +
  scale_y_continuous(breaks = sort(c(0, 50, h, 100, 150, 200))) +
  facet_grid(rows = "flash", scales = "free_y") +
  labs(#title = "Period lengths per camera",
       x = "Location", y = "Days since deployment") # 
  

p_td2 + #ggpubr::theme_classic2() +
  theme(legend.position = "none", axis.text.y = element_blank(), axis.ticks.y = element_blank()) +
        scale_linetype_manual(values = rep(c("solid","solid"), 4) ) + #option to change to solid,dashed
        scale_color_manual(values = c(rep(c("#74add1","#4575b4"), each = 2), # trt-colr
                                      rep(c("#fdae61","#f46d43"),each = 2) ) )  #ctrl-colr
  #labs(caption = "Vertical line represents the median IR period length. \n Data superceding that were trimmed away for the GLMM")
```



_Lastly, performing the filter:_
```{r time.dep4-filtr}
# filtering out periods longer than (shortest) median length.
time.dep4 <- time.dep3 %>% filter(time.deploy < h/10) # h is normal scale, must be rescaled by /10
# time.dep5 <- time.dep4 %>% mutate(time.deploy = time.deploy / .7) # scaled by 1 weeks (84=12*7(1w))

# time.dep4$loc %>% unique() %>% is.na() %>% any() # no NAs in loc
summary(time.dep4) #            
```

# Counts of species

```{r events}
sp_eng <- c("Roe deer", "Red fox", "Badger", "Hare", "Red squirrel", "Moose", "Red deer", "Pine marten","Lynx")
sp_eng <- sp_eng[9:1] # reverse order
sp_count <- time.dep4 %>% group_by(species, flash) %>% filter(n.obs > 0, species %in% sp_focus) %>% 
  summarise(count = sum(n.obs))
p_count <- ggplot(sp_count, aes(reorder(species, count, FUN = mean),count)) +
  labs(x= "Species", y = "Events") +
  # scale_y_continuous(breaks = sp_count$count) + guides(x = guide_axis(n.dodge = 2))
  scale_y_continuous(n.breaks = 10) + scale_x_discrete(labels = sp_eng) +
  geom_col(aes(fill=flash), colour = "black") +
  scale_fill_bluebrown(reverse=T) +
  theme(axis.title.x = element_blank(),legend.position = "none",
        legend.title = element_blank()) 

 p_count + coord_flip() +
   theme(legend.box.background = element_rect(),axis.title.y = element_blank(),
                legend.position = c(.8, .3),legend.justification = c("left", "top"))
 
# data without flash-grouping
sp_count_trim <- time.dep4 %>% group_by(species) %>% filter(n.obs > 0, species %in% sp_focus) %>% 
  summarise(count = sum(n.obs))
sp_count_full <- time.dep3 %>% group_by(species) %>% filter(n.obs > 0, species %in% sp_focus) %>% 
  summarise(count = sum(n.obs))
# plot full and trimmed on top of each other
ggplot(sp_count_full, aes(reorder(species, count, FUN = mean),count)) +
  labs(x= "Species", y = "Events") +
  scale_y_continuous(n.breaks = 10) + 
  geom_col() +
  geom_col(data=sp_count_trim, fill="blue") +
  geom_label(aes(x=species,y=count,label = count))
```


```{r active-days}
active_trimmed <- time.dep4 %>% group_by(loc, period, period_length, flash) %>% 
  summarise(days_trim = max(time.deploy))
# by flash
active_f <- active_trimmed %>% group_by(flash) %>% 
  summarise(Trimmed = sum(days_trim * 10), # rescaling to true n days
            Full = sum(period_length * 10) ) %>% # for both variables
  reshape2::melt(measure=c("Full","Trimmed"), id="flash") #melt both into one variable
# plot
ggplot(active_f,aes(flash,value,fill=variable)) +
  geom_col(position = "dodge") +
  scale_fill_bluebrown() + labs(x= "Period group", y= "Number of active camera trapping days",
                                caption = "Total number of active camera trapping days per period group in blue,\n and active camera days included in the GLMM after trimming the periods.") +
   geom_label(aes(label=value),nudge_x = rep(c(-.23,.23),each=3), show.legend = F ) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.title.x = element_blank())


# by period
active_p <- active_trimmed %>% group_by(period, flash) %>% 
  summarise(Trimmed = sum(days_trim * 10), # rescaling to true n days
            Full = sum(period_length * 10) ) %>% # for both variables
  reshape2::melt(measure=c("Full","Trimmed"), id=c("period","flash")) #melt both into one variable
ggplot(active_p,aes(period,value,fill=variable)) +
  geom_col(position = "dodge") +
  scale_fill_bluebrown() + labs(x= "Period group", y= "Number of active camera trapping days") +
  facet_wrap(~flash, scales = "free_x") +
  guides(x = guide_axis(check.overlap = T)) +
  theme(legend.position = "bottom", legend.title = element_blank(),
        axis.title.x = element_blank())

# periods stacked on flash + faceted
p_days <- active_p %>% mutate(period = fct_rev(period)) %>% 
ggplot(aes(flash,value,fill=flash,col=period)) +
  geom_col() +
  scale_fill_bluebrown(reverse = T) + #flash fill colours
  scale_color_grey(start = 0, end = 0) + #black surrounding colour
  labs(x= "Period group", y= "Active camera trapping days") +
  geom_text(aes(label = period), position = position_stack(vjust = 0.5)) + # ,show.legend = F) +
  facet_wrap(~variable) +
  theme(legend.position = "none", axis.title.x = element_blank())
p_days

```


```{r days-count, eval=FALSE}
plot_grid(p_count +
            scale_y_continuous(breaks = c(100,300,500,700,900,1100,1300),
                               sec.axis = dup_axis(name = element_blank())) ,
          p_days + 
            scale_y_continuous(#n.breaks = 7,
                               sec.axis = dup_axis(name = element_blank()) ),
          nrow = 2,
          rel_heights = c(2,3))
```

# Yearly activity

```{r year-activity}
sp_focus <- c("raadyr", "rev", "grevling", "hare", "ekorn", "elg", "hjort", "maar", "gaupe")
sp_carnivora <- c("rev", "grevling", "maar", "gaupe")
sp_ruminata <- c("raadyr", "elg", "hjort","hare", "ekorn")
# sp_rodenta <- c("hare", "ekorn") # I know they're not both rodents

obs_activity <- obs %>% filter(species %in% sp_focus) %>% 
  mutate(flash = fct_shift(flash,-1), #reordering flash-factor
         week = lubridate::isoweek(date),
         month = lubridate::month(date),
         year = lubridate::year(date))
obs_activity$order[obs_activity$species %in% sp_carnivora] <- "Carnivora"
obs_activity$order[obs_activity$species %in% sp_ruminata] <- "Ruminata"
# obs_activity$order[obs_activity$species %in% sp_rodenta] <- "Rodenta"
obs_activity %>% 
ggplot(aes(week)) +
  #geom_bar(col="black", fill="white") +
  geom_freqpoly(aes(#y=..density..,#*20*count, #scaling density with the count
                   col=species, alpha=.1),
               show.legend = c(alpha = F), bw=1.2) +
  theme(legend.position = "top") #legend placement
# obs_avg <- obs_activity %>% 
#   group_by(species) %>% summarise(week = max(week),
#                                   count = median(count, na.rm = T))
obs_activity %>% group_by(species, year, week, order) %>% 
  summarise(count = n()) %>% 
ggplot(aes(week)) +
  #geom_bar(col="black", fill="white") +
  geom_smooth(aes(y=count,col=species),se = FALSE) +
  # scale_x_continuous(breaks = seq(0,23, by=4)) + # which x-ticks
  # scale_y_continuous(n.breaks = 6) + # n y-ticks
  facet_wrap(~order, nrow = 3) +
  ggrepel::geom_label_repel(aes(y = median(count),label = species)) +
  theme(legend.position = "none") #legend placement
        # legend.title = element_blank(), legend.key.size = unit(2, 'mm'), #size
        # legend.box.just = "right")+ 


```




# Modelling

The following code chunks are written in a modular fashion, so that everything will be done identically for each species. Any changes made will affect all species.

```{r sp, eval=FALSE}
# sp ="raadyr"  #(shortcut for when editing)
# n locations that detected the species
n_loc <- time.dep4$loc[time.dep4$n.obs > 0 & time.dep4$species %in% sp] %>% unique()
# subsetting data for species, and the locations where it was detected
time_sp <- filter(time.dep4,       #.dep4 = trimmed data
                  species %in% sp, # filtering species
                  loc %in% n_loc)  # filtering locations
# Model
m_sp  <- lme4::glmer(n.obs ~ time.deploy * flash + # fixed effects
            (1 | loc) + (1 | week),                # random effects
            data   = time_sp,       # subset data
            family = poisson) # poisson family of distributions because of count data

# ggeffect calls effects::Effect - for plotting marginal effects 
p_sp    <- ggeffects::ggeffect(m_sp, terms = c("time.deploy [all]", "flash"))
# Diagnostics
assumpt <- performance::check_model(m_sp) # check assumptions
# va_r <- insight::get_variance(m_sp)
```




```{r sp-report, eval=FALSE}
# Summary, report, model
summary(m_sp)
r_sp <- report::report(m_sp) # text-summary of my model, to include in a report
para_sp  <- model_parameters(m_sp,   standardize = "refit") # model parameters
saveRDS(m_sp, file = paste0("m_",sp,".rds")) # save model objects as shortcut for when editing etc.
```


## Roe deer

In the following chunk, knitr will call the code chunks referenced in the 'ref.label' command. The same effect can be achieved by calling the code chunk name inside '<< >>'.

`r sp = "raadyr"`
```{r raadyr, ref.label=c('sp','sp-report'), cache=TRUE}
#<<sp>>
#<<sp-report>>
```


### Plots

```{r, eval=FALSE}
# just a shortcut for when editing
## I still haven't found out how to make knitr calling other chunks
## without actually knitting (which is timeconsuming).
sp="raadyr"
m_sp <- readRDS("m_raadyr.rds")
# m_sp <- readRDS("m_grevling.rds")
p_sp <- ggeffects::ggeffect(m_sp, terms = c("time.deploy [all]", "flash"))
va_r <- insight::get_variance(m_sp)
```

```{r density, eval=FALSE}
# trying to include total counts in labels:
c <- obs %>% filter(species %in% sp) %>% 
  group_by(flash) %>% 
  summarise(count = n())
lab_ctrl <- paste0("Control (",c[3,2],")")
lab_IR   <- paste0("IR \    (",c[1,2],")")
lab_LED  <- paste0("wLED \   (",c[2,2],")")


# Density plots
p_dens <- obs %>% filter(species %in% sp) %>% 
  mutate(flash = fct_shift(flash,-1)) %>% #reordering flash-factor
  ggplot(aes(Hour)) +
  geom_bar(col="black", fill="white") +
  geom_density(aes(y=..density..*20*count, #scaling density with the count
                   fill=flash, alpha=.1),
               show.legend = c(alpha = F), bw=1.2) +
  scale_x_continuous(breaks = seq(0,23, by=4)) + # which x-ticks
  scale_y_continuous(n.breaks = 6) + # n y-ticks
  theme(legend.position = c(1, 1), legend.justification = c(.1, 2), #legend placement
        legend.title = element_blank(), legend.key.size = unit(2, 'mm'), #size
        legend.box.just = "right")+ 
  scale_fill_bluebrown(reverse = T, breaks = c("Control", "IR", "wLED")
                    #labels=c(lab_ctrl, lab_IR, lab_LED)
                    )



# Trying to map activity patterns to before and after sunrise/sunset

# library(overlap)
# obs$hour <- as.numeric(format(obs$datetime, "%H")) # setting up time cols 
# obs$mins <- as.numeric(format(obs$datetime, "%M")) # in a way that overlap
# obs$rad <- ((obs$hour * 60 + obs$mins)/(24 * 60)) * 2 * pi  # understands
# 
# overlap_flash <- function(x, colour = c("black", "blue", "brown"), rug = FALSE, main = str_to_title(x), ...) {
#   x0 <- obs[obs$species %in% x & obs$flash == "IR", ]$rad
#   x1 <- obs[obs$species %in% x & obs$flash == "LED", ]$rad
#   x2 <- obs[obs$species %in% x & obs$flash == "Control", ]$rad
#   overlapPlot(x2, x1, x0, linecol = rep(colour, 3), rug = rug, main = main, 
#               linewidth = c(2, 2), olapcol = "darkgrey", extend = "lightgrey", ...)
#   x.est <- round(overlapEst(x1, x0, type = "Dhat4"), 2)
#   n0 <- length(x0)
#   n1 <- length(x1)
#   legend("top", legend = str_c("Dhat4", x.est, sep = " = "), bty = "n")
# #  legend("bottomleft", legend = c(str_c("LED n", n1, sep = " = "), str_c("    IR n", n0, sep = " = ")),
# #         col = colour, lty = c(1, 2), lwd = 2, bty = "7")
# }
# 
# overlap_flash("rev", rug=T)
# obs$species
# 
#   x0 <- obs[obs$species %in% sp & obs$flash == "IR", ]$rad
#   x1 <- obs[obs$species %in% sp & obs$flash == "LED", ]$rad
#   x2 <- obs[obs$species %in% sp & obs$flash == "Control", ]$rad
# overlapPlot(x0,x1)
# 
# overlap::sunTime()


#yearly activity

obs_activity %>% filter(species %in% sp) %>% 
  # summarise(count = n()) %>% 
ggplot(aes(week)) +
  #geom_bar(col="black", fill="white") +
  geom_freqpoly() +
  # scale_x_continuous(breaks = seq(0,23, by=4)) + # which x-ticks
  # scale_y_continuous(n.breaks = 6) + # n y-ticks
  theme(legend.position = "none") #legend placement
        # legend.title = element_blank(), legend.key.size = unit(2, 'mm'), #size
        # legend.box.just = "right")

```




```{r parameters}
library(cowplot) # to make grid-plots
library(magick)
# ggpredict
p_sp1 <- plot(p_sp, ci.style = c("dash"), line.size = 1, #ci.styles: “ribbon”, “errorbar”, “dash”, “dot”
               colors = c("black","#e41a1c","#377eb8")) +
   labs(title="", x="Time since deployment (per 10 days) \ ", y="Detection rate") +
   ggpubr::theme_classic2() +
  theme(legend.position = "top", legend.title = element_blank(),
        axis.title = element_text(size = 11)) 

# standardized plots aren't very different, other than on the scale
#plot(para_sp, size_text = 3) + labs(title = paste0(sp, " GLMM parameters") ,
#                                    subtitle = 'standardize  = "refit" ')

# Equivalence test
result <- equivalence_test(m_sp)
result

# labels for equivalence test - prettier to the human eye
par_lab <- c("Time", "IR", "wLED", "Time * IR", "Time * wLED")
par_lab <- par_lab[5:1]
# Equivalence plot
p_eq <- plot(result) + labs(y = "Log-Mean") + 
    scale_x_discrete(labels = par_lab) + # new axis names
    theme(#legend.position = c(1, .5), legend.justification = c(1, 1),#legend placement
        legend.position = "top") +#,  
        # axis.text.y = element_text(vjust = -0.7, hjust = 0, # axis-text inside
        #                          margin = margin(l = 10, r = -55)),
        #   axis.ticks.length.y = unit(-1,"mm")) + # inward axis ticks
    guides(colour = guide_legend(nrow = 2, override.aes = list(size = .5),
                                 title.theme = element_text( 
                                   size=10, #adjusting legend appearance
                                   face="italic"))) 
# Density plots
p_dens <- obs %>% filter(species %in% sp) %>% 
  mutate(flash = fct_shift(flash,-1)) %>% #reordering flash-factor
  ggplot(aes(Hour)) +
  geom_bar(col="black", fill="white") +
  geom_density(aes(y=..density..*20*count, #scaling density with the count
                   fill=flash, alpha=.1),
               show.legend = c(alpha = F), bw=1.2) +
  scale_x_continuous(breaks = seq(0,23, by=4)) + # which x-ticks
  scale_y_continuous(n.breaks = 6) + # n y-ticks
  theme(legend.position = c(1, 1), legend.justification = c(.1, 2), #legend placement
        legend.title = element_blank(), legend.key.size = unit(2, 'mm'), #size
        legend.box.just = "right")+ 
  scale_fill_bluebrown(reverse = T, breaks = c("Control", "IR", "wLED")
                    #labels=c(lab_ctrl, lab_IR, lab_LED)
                    )

# cowplot::plot_grid(NULL,NULL,p_dens,NULL,
#                    #nrow = 2,
#                    # rel_widths = c(3,4,6,1),
#                    # rel_heights = c(3,2),
#                    labels="auto",
#                    axis = "r"
# ) 


sp_file <- paste0("jpg/",sp,".JPG")
jpg <- ggdraw() + draw_image(sp_file, halign = 1)

p_grid <- cowplot::plot_grid(p_sp1,
                             p_eq,
                             p_dens,
                             jpg,
                   #nrow = 2,
                   rel_widths = c(3,4),
                   rel_heights = c(3,2),
                   labels="auto"
                   #align = "h"
) + labs(title = paste0(sp, " present at ",n_loc," sites."))
p_grid #+ draw_image(sp_file, scale = .4, x = 0.9,
       #  hjust = 1, halign = 1, valign = 0)
```




```{r sp-report2}
summary(r_sp)
as.report_table(r_sp)
```

Finally, storing all objects as species specific objects, for summary stuff at the end of the document.

```{r raadyr-objects}
# Storing species-specific objects for later, as shortcuts
# Model
m_raa    = m_sp
# ggpredict 
p_raa    = p_sp
# report-object
r_raa    = r_sp
# parameters refit
para_raa = para_sp
```

__Chunk order:__

1. sp
1. sp-report
1. sp-report2
1. parameters
1. objects


## Red Fox

`r sp = "rev"` 
This is where I change the content of the species object 'sp'. I have to do it before calling the pre-defined code chunks.

Now, sp contains `r sp`.

```{r rev, ref.label=c('sp','sp-report'), cache=TRUE}
```
### Plot

```{r rev2, ref.label=c('sp-report2','parameters')}
```


```{r rev-objects, cache=TRUE}
# Model
m_rev    = m_sp
# ggpredict 
p_rev    = p_sp
# report-object
r_rev    = r_sp
# parameters refit
para_rev = para_sp
```


```{r knit-exit, eval=FALSE}
knitr::knit_exit()
# Exita knitting process here instead of at the document end
# Perfect for doing a test run, checking if the code works for at least two different species
# Set to eval=FALSE as default, needs to be adjusted to TRUE before a test run.
```


## Badger

`r sp = "grevling"`
Now, sp contains `r sp`.

```{r grevling, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r grevling2, ref.label=c('sp-report2','parameters')}
```


```{r grevling-objects, cache=TRUE}
# Model
m_grvl    = m_sp
# ggpredict 
p_grvl    = p_sp
# report-object
r_grvl    = r_sp
# parameters refit
para_grvl = para_sp
```


## Moose

`r sp = "elg"`
Now, sp contains `r sp`.

```{r elg, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r elg2, ref.label=c('sp-report2','parameters')}
```


```{r elg-objects, cache=TRUE}
# Model
m_elg    = m_sp
# ggpredict 
p_elg    = p_sp
# report-object
r_elg    = r_sp
# parameters refit
para_elg = para_sp
```

## Red deer

`r sp = "hjort"`
Now, sp contains `r sp`.

```{r hjort, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r hjort2, ref.label=c('sp-report2','parameters')}
```


```{r hjort-objects, cache=TRUE}
# Model
m_hjort    = m_sp
# ggpredict 
p_hjort    = p_sp
# report-object
r_hjort    = r_sp
# parameters refit
para_hjort = para_sp
```


## Lynx

`r sp = "gaupe"`
Now, sp contains `r sp`.

```{r gaupe, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r gaupe2, ref.label=c('sp-report2','parameters')}
```


```{r gaupe-objects, cache=TRUE}
# Model
m_gaup    = m_sp
# ggpredict 
p_gaup    = p_sp
# report-object
r_gaup    = r_sp
# parameters refit
para_gaup = para_sp
```


# Small species

Added late, because I was unsure about whether it made sense to include them or not.
After having learned about random effects in mixed effect models, I think it does make sense, even though the cameras in my study were set up with the original aim of photo capturing lynx.

## Hare

`r sp = "hare"`
Now, sp contains `r sp`.

```{r hare, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r hare2, ref.label=c('sp-report2','parameters')}
```


```{r hare-objects, cache=TRUE}
# Model
m_hare    = m_sp
# ggpredict 
p_hare    = p_sp
# report-object
r_hare    = r_sp
# parameters refit
para_hare = para_sp
```


## Red squirrel

`r sp = "ekorn"`
Now, sp contains `r sp`.

```{r ekorn1}
time_sp <- filter(time.dep4, species %in% sp) #.dep4 = trimmed data
# Model
m_sp  <- lme4::glmer(n.obs ~ time.deploy * flash + # fixed effects
            (1 | loc) + (1 | week), # random effects
            data   = time_sp,
            family = poisson,
            nAGQ = 0) # change optimizer to oenalized iteratively reweighted least squares step
# ggeffect calls effects::Effect
p_sp    <- ggeffects::ggeffect(m_sp, terms = c("time.deploy [all]", "flash"))
# Diagnostics
assumpt <- performance::check_model(m_sp) # check assumptions
va_r <- insight::get_variance(m_sp)
```


```{r ekorn, ref.label=c('sp-report'), cache=TRUE}

```

### Plot

```{r ekorn2, ref.label=c('sp-report2','parameters')}
```


```{r ekorn-objects, cache=TRUE}
# Model
m_ekorn    = m_sp
# ggpredict 
p_ekorn    = p_sp
# report-object
r_ekorn    = r_sp
# parameters refit
para_ekorn = para_sp
```



## European Pine marten

`r sp = "maar"`
Now, sp contains `r sp`.

```{r maar, ref.label=c('sp','sp-report'), cache=TRUE}
```

### Plot

```{r maar2, ref.label=c('sp-report2','parameters')}
```


```{r maar-objects, cache=TRUE}
# Model
m_maar    = m_sp
# ggpredict 
p_maar    = p_sp
# report-object
r_maar    = r_sp
# parameters refit
para_maar = para_sp
```



----------------------------------------------

# All models


## Parameter-table

Making parameter-tables to include in my thesis. The first one contains standardized parameters, but since that differs from the format they are presented in the equivalence test, I will using the second one, which is not standardized

```{r model-report}
library(xtable)  # To make a latex-table for the thesis
para_raa  <- para_raa %>% 
  add_row(Parameter = "Roe deer", .before = 1) # adds a row for species name in the resulting table
para_rev  <- para_rev   %>% add_row(Parameter = "Red fox",  .before = 1)
para_grvl <- para_grvl  %>% add_row(Parameter = "Badger",   .before = 1)
para_elg  <- para_elg   %>% add_row(Parameter = "Moose",    .before = 1)
para_hjort<- para_hjort %>% add_row(Parameter = "Red deer", .before = 1)
para_gaup <- para_gaup  %>% add_row(Parameter = "Lynx",     .before = 1)
para_hare <- para_hare  %>% add_row(Parameter = "Hare",     .before = 1)
para_maar <- para_maar  %>% add_row(Parameter = "European Pine Marten", .before = 1)
para_ekorn<- para_ekorn %>% add_row(Parameter = "Red squirrel", .before = 1)

# bind tables together
para_all <- bind_rows(para_raa, para_rev, para_grvl,para_elg,para_hjort,para_gaup,para_hare,para_maar,para_ekorn) %>%
  insight::format_table(ci_brackets = c("(", ")")) %>% #prettier ci-brackets
  select(!df) # remove the df-column, containing "Inf" for every species

# save as latex-table in the Thesis folder
print(xtable(para_all, type = "latex"), include.rownames = F,
      file = "../Thesis/tex/tab/parameters.tex")
xtable(para_all) # output in Rmd
```


```{r model-report2-setup, eval=FALSE}
library(xtable)  # To make a latex-table for the thesis
m_raa  <- readRDS("m_raadyr.rds")    
m_rev  <- readRDS("m_rev.rds") 
m_grvl <- readRDS("m_grevling.rds") 
m_elg  <- readRDS("m_elg.rds")
m_hjort<- readRDS("m_hjort.rds") 
m_gaup <- readRDS("m_gaupe.rds")
m_hare <- readRDS("m_hare.rds")
m_maar <- readRDS("m_maar.rds")
m_ekorn<- readRDS("m_ekorn.rds")
```


```{r model-report2}
# gather all models
m_all <- list(m_raa, m_rev ,m_grvl, m_hare, m_ekorn, m_elg, m_hjort, m_maar, m_gaup)
#sp <- c("raadyr", "rev", "grevling", "hare", "ekorn", "elg", "hjort", "maar", "gaupe")
# not standardized
para_all2 <- bind_rows(
model_parameters(m_raa)   %>% add_column(Species = c("Roe deer",            rep("",5)), .before = 1),
model_parameters(m_rev)   %>% add_column(Species = c("Red fox",             rep("",5)), .before = 1),
model_parameters(m_grvl)  %>% add_column(Species = c("Badger",              rep("",5)), .before = 1),
model_parameters(m_elg)   %>% add_column(Species = c("Moose",               rep("",5)), .before = 1),
model_parameters(m_hjort) %>% add_column(Species = c("Red deer",            rep("",5)), .before = 1),
model_parameters(m_gaup)  %>% add_column(Species = c("Lynx",                rep("",5)), .before = 1),
model_parameters(m_hare)  %>% add_column(Species = c("Hare",                rep("",5)), .before = 1),
model_parameters(m_maar)  %>% add_column(Species = c("European Pine Marten",rep("",5)), .before = 1),
model_parameters(m_ekorn) %>% add_column(Species = c("Red squirrel",        rep("",5)), .before = 1)
) %>% 
 insight::format_table(ci_brackets = c("(", ")")) %>% #prettier ci-brackets
  select(!df) # remove the df-column, containing "Inf" for every species
para_all2$Parameter <- rep(c("(Intercept)","TimeDeploy","IR","wLED", "TimeDeploy * IR", "TimeDeploy * wLED"), times=9)
# save as latex-table in the Thesis folder
print(xtable(para_all2, type = "latex"), include.rownames = F,
      file = "../Thesis/tex/tab/parameters2.tex")
```

## Joint forest-plots

Plots divided into size-based groups.
Unlikely to be included in the thesis.

```{r mod-plot}
p_mds1<- sjPlot::plot_models(m_raa, m_rev, m_grvl, m_elg, m_hjort, spacing = .8,
                    legend.title = "Species",
                    m.labels = c("Roe deer","Red fox","Badger","Moose","Red deer"))
p_mds2 <- sjPlot::plot_models(m_hare, m_maar,m_ekorn,m_gaup, spacing = .8,
                    legend.title = "Species",
                    m.labels = c("Hare","Pine marten","Red squirrel","Lynx"))
```


## Model comparison-plots

Whichs species' detection rates was best explained by the my model formula?

```{r mod-comparisons}
m_compare <- compare_performance(m_raa,m_rev,m_grvl,m_elg,m_hjort,
                                 m_gaup, m_hare, m_ekorn, m_maar,
            metrics = "common", rank=T) # "common" will compute AIC, BIC, R2, ICC and RMSE
m_compare
m_compare %>% plot() #A `range` must be provided for data with only one observation.
# test_performance(m_raa,m_rev,m_grvl,m_elg,m_hjort,m_gaup) #models don't have the same response variable, 
# which is because they are different subsets of each other
```

## Model assumptions
The following section includes a lot of citing from other sources, mainly to help future me understand everything anew, and to get some pointers on where to read further.

```{r mod-checks, eval=FALSE}
overd <- list()
zeroi <- list()
singu <- list()

for (i in 1:9) {
overd[[i]] <- check_overdispersion(m_all[[i]])
zeroi[[i]] <-  check_zeroinflation(m_all[[i]])
singu[[i]] <- check_singularity(m_all[[i]])
}

overd # No overdispersion detected
zeroi # Model seems ok, ratio of observed and predicted zeros is within the tolerance range.
singu %>% unique() # FALSE
#citation("performance")
performance::check_autocorrelation(m_raa)
```

Using the performance-package from easystats (Lüdecke, Makowski, Waggoner & Patil (2020)), no overdispersion was detected.
>Overdispersion occurs when the observed variance is higher than the variance of a theoretical model. For Poisson models, variance increases with the mean, thus, variance usually (roughly) equals the mean value. If the variance is much higher, the data are "overdispersed". (performance::check_singularity, R help file)

Dispersion ratios lied between 0.65 (squirrel) and 0.94 (pine marten).
>If the dispersion ratio is close to one, a Poisson model fits well to the data. Dispersion ratios larger than one indicate overdispersion, thus a negative binomial model or similar might fit better to the data. A p-value < .05 indicates overdispersion.

The R documentation also states that Poisson model's overdispersion test is based on the code from _Gelman and Hill (2007), page 115._ 
And that the function for mixed models only returns _approximate_ estimates, which is probably inaccurate for zer-inflated mixed models (fitted with glmmTMB). The documentations doesn't mention poisson mixed models specifically, but as no models were zero-inflated, I will assume the dispersion ratios are fine.

>If the amount of observed zeros is larger than the amount of predicted zeros, the model is underfitting zeros, which indicates a zero-inflation in the data. In such cases, it is recommended to use negative binomial or zero-inflated models. (performance::check_zeroinflation, R help file)

No models were zero-inflated, nor singular.
>If a model is "singular", this means that some dimensions of the variance-covariance matrix have been estimated as exactly zero. This often occurs for mixed models with complex random effects structures. (performance::check_singularity, R help file)

In other words, there weren't more zeros than predicted and my random effects structure wasn't overly complicated.




### Assumptions of Poisson regression 
(from https://www.statology.org/poisson-regression/, accessed 22.03.2021)

__Assumption 1:__ The response variable consists of count data. In traditional linear regression, the response variable consists of continuous data. To use Poisson regression, however, our response variable needs to consists of count data that include integers of 0 or greater (e.g. 0, 1, 2, 14, 34, 49, 200, etc.). Our response variable cannot contain negative values.

__Assumption 2:__ Observations are independent. Each observation in the dataset should be independent of one another. This means that one observation should not be able to provide any information about a different observation.

__Assumption 3:__ The distribution of counts follows a Poisson distribution. As a result, the observed and expected counts should be similar. One simple way to test for this is to plot the expected and observed counts and see if they are similar.

__Assumption 4:__ The mean and variance of the model are equal. This is a result of the assumption that the distribution of counts follows a Poisson distribution. For a Poisson distribution the variance has the same value as the mean. If this assumption is satisfied, then you have equidispersion. However, this assumption is often violated as overdispersion is a common problem.









--------------------------------------------


### Blueprint for other species in chunk below:

<!--`r sp = "xx"`-->

```{r xx, ref.label=c('sp','sp-report'), eval=FALSE}
```
```{r xx2, ref.label=c('sp-report2','parameters'), eval=FALSE}
```


```{r xx-objects, eval=FALSE}
# Model
m_xx    = m_sp
# ggpredict 
p_xx    = p_sp
# report-object
r_xx    = r_sp
# parameters refit
para_xx = para_sp
```


----------------------------------------------

# SessionInfo

```{r sessionInfo}
sessionInfo()

report_parameters(sessionInfo()) # output to include in Appendix
```

