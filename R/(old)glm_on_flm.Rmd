---
title: "glm on flm"
output: html_notebook
---
------------------------------------------------------------
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
options(tibble.print_min = 5)
library(pander)     # for prettier outputs of summaries and tables etc.
library(report)     # for reporting test-statistics 
library(tidyverse)  # entering the tidyverse
library(tidymodels) # and bringing the model-toolbox
library(modelr)
library(lubridate)  # lubricating the handling of dates
library(survival)   # the original survival-package
library(survminer)  # a plot-package for ggplot integration
library(vip)        # for variable importance plots
library(equatiomatic) # Model formula displayer in RMarkdown
``` 

## Generalised Linear Models

## filtering out species
I don't know if this is specially useful for survival modelling, selecting variables and all that.
My models should only include one species per time anyway.
```{r obs-glm}
covs <- readRDS("CTloc_covs.rds")
obs <- readRDS("obs_tte5.rds") %>% 
  rename(species = validated_species) %>%
  merge(covs, by.x="loc", by.y="LokalitetID", all.x=TRUE, all.y=FALSE) %>% 
  # removing various IDs, lat lon which correlates with slope, build dens,
  # field_d2, as well as geometry which I don't understand what is
  select(-c(4:9, 11, 19:21) )
obs <- obs %>% 
  # Exclude missing data
  na.omit() %>% 
  # For creating models, it is better to have qualitative columns
  # encoded as factors (instead of character strings)
  mutate_if(is.character, as.factor) %>% 
  mutate(house_d2_ln = ifelse(obs$house_d2>0,log(obs$house_d2), 0),
         forestroad_d2_io = ifelse(obs$forestroad_d2>10, 0, 1),
     forestroad_d2_ln = ifelse(obs$forestroad_d2>0, log(obs$forestroad_d2),0))


obs %>% 
  skimr::skim(species, flash) 
# names(obs)
# sp = c("raadyr","rev","grevling","elg","hjort", "gaupe")
obs %>% 
  count(flash) %>% 
  mutate(prop = n/sum(n)) %>% 
  pander() # no flashed individuals during no-flash period

```




```{r glm-raadyr}
# sp="raadyr"
# 
# # Witout any random effects
# my.glm<-glm(round(t.diff)~flashed+house_d2_ln + forestroad_d2_ln, 
#             data=obs[obs$validated_species%in%sp & !obs$period%in%"Control",], family="poisson")
# summary(my.glm)

```

```{r}
library(modelr)
nz <- filter(obs, species == "raadyr")
nz %>% 
  ggplot(aes(t.diff, event)) + 
  geom_line() + 
  ggtitle("Full data = ")



nz_mod <- glm(round(t.diff) ~ flashed + house_d2_ln + forestroad_d2_io, data = nz)
nz %>% 
  add_predictions(nz_mod) %>%
  ggplot(aes(t.diff, pred)) + 
  geom_line() + 
  ggtitle("Linear trend + ")

nz %>% 
  add_residuals(nz_mod) %>% 
  ggplot(aes(t.diff, resid)) + 
  geom_hline(yintercept = 0, colour = "white", size = 3) + 
  geom_line() + 
  ggtitle("Remaining pattern")
```

```{r}
fjern <- c("smagnagere", "andre_maardyr", "andre_pattedyr", "motorsykkel","sykkel","null","ulv", "villsvin","rugde")
#"nothing","hund", "menneske", "kjoeretoey",  "ukjent","sau", "ku", "fugl", "skogshons", 
by_sp <- obs %>% 
  group_by(species) %>%
  filter(!species %in% fjern) %>% 
  nest()
by_sp

```

```{r}
library(lme4)
sp_model <- function(df) {
#  glm(t.diff ~ flashed + house_d2_ln + forestroad_d2_io, 
 coxph(Surv(t.diff, event, type="right")~flashed+ house_d2_ln + forestroad_d2_io,
     data = df #, family = poisson
     )
}

# models <- map(by_sp$data, sp_model)
```

However, rather than leaving the list of models as a free-floating object, I think it’s better to store it as a column in the by_country data frame. Storing related objects in columns is a key part of the value of data frames, and why I think list-columns are such a good idea. In the course of working with these countries, we are going to have lots of lists where we have one element per country. So why not store them all together in one data frame?

In other words, instead of creating a new object in the global environment, we’re going to create a new variable in the by_country data frame. That’s a job for dplyr::mutate():

```{r}
by_sp <- by_sp %>% 
  mutate(model = map(data, sp_model))
#All related objects are stored together, therefore I don't need to manually keep them in sync when I filter or arrange
by_sp %>% 
  arrange(species)
```
## Unnesting

`r broom::glance(nz_mod)`
```{r}
glance <- by_sp %>% 
  mutate(glance = map(model, broom::glance)) %>% 
  unnest(glance) %>% select(!2:4)
glance
```

```{r}
glance %>% 
  arrange(r.squared)
```

```{r}
glance %>% 
  ggplot(aes(species, r.squared)) + 
    geom_point(width = 0.5) +coord_flip()
```
```{r}
bad_fit <- filter(glance, r.squared < 0.25)

obs %>% 
  semi_join(bad_fit, by = "species") %>% 
  ggplot(aes(t.diff, event, colour = species)) +
    geom_jitter()
```




##on coxph model

```{r}

cfit <- coxph(Surv(t.diff, event, type="right")~flashed+ house_d2_ln + forestroad_d2_ln ,#+ strata(species),
     data = obs)

tidy(cfit)
tidy(cfit, exponentiate = TRUE)

lp <- augment(cfit, obs)
risks <- augment(cfit, obs, type.predict = "risk")
expected <- augment(cfit, obs, type.predict = "expected")

glance(cfit)


```

